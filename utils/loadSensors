#!/usr/bin/env python3

"""
This script adds and populates tables Modules and Sensors. 
These tables change only when sensors are added or there is a change to the sensor modules.
If the database does not exist then it is created.
If tables already exists then they are deleted and recreated with the new data.
Table Modules is only for descriptions of the profiles and is not yet used.

Table Sensors is added and file `sensorLocations` is used to populate the locations. 
The lines in the file are expected to be as generated by Grasshopper script,
See grasshopperNotes.txt for more details.

The modIDs and sockets fields are then filled using file SensorIdHash.txt.
The IDs and locations, but not the module and socket information, are used for display in Grasshopper.
However, the module and socket information is usful when problems are detected with sensors.

This program is only python with SQL. 
See extractSensorReadingsSliceSQLite.py for a grasshopper python script to extract data
from the database and use it in Grasshopper.

Usage:
loadSensors  --sensorLocations=locationsFile --SensorIdHash=SensorIdHashFile \
      --ModuleIdHash=modulesFile --outdb=OutputDatabaseName 

Example:
loadSensors  --sensorLocations='sensorLocations.txt' --SensorIdHash='SensorIdHash.txt' \
     --ModuleIdHash='ModuleIdHash.txt' --outdb='SensorReadings_2026-01-19.db'
"""
import argparse
import os
#import datetime
import sqlite3

parser = argparse.ArgumentParser(description= 
           'Create and populate SQLite db.')

parser.add_argument('--sensorLocations', type=str, default='sensorLocations.txt',
                    help='input data file as produced by extractSensorsLocations.ghx. Default: sensorLocations.txt')

parser.add_argument('--SensorIdHash', type=str, default='SensorIdHash.txt',
                    help='input data file as manually edited with install information. Default: SensorIdHash.txt')

parser.add_argument('--ModuleIdHash', type=str, default='ModuleIdHash.txt',
                    help='input data file as manually edited module profile description. Default: ModuleIdHash.txt')

parser.add_argument('--outdb', type=str, default='SenorReadings.db',
                    help='input data file as produced by SensorDataReformat. Default: SenorReadings.db')

args = parser.parse_args()

locationPath=args.sensorLocations
#print(locationPath)

if not os.path.isfile(locationPath): 
   print('file   ' + locationPath +' does not exist.')
   exit(1)

SensorIdHashpath = args.SensorIdHash
if not os.path.isfile(SensorIdHashpath): 
   print('file   '  + SensorIdHashpath +' does not exist.')
   exit(1)

ModuleIdHashpath = args.ModuleIdHash
if not os.path.isfile(ModuleIdHashpath): 
   print('file   '  + ModuleIdHashpath +' does not exist.')
   exit(1)

dbpath = args.outdb

###################################################################
con = sqlite3.connect(dbpath)

# drop the table if it exists, so it can be replaced
con.execute("DROP TABLE IF EXISTS Modules")

#create and populate Modules  table
con.execute("""
  CREATE TABLE IF NOT EXISTS Modules (
    modID TEXT PRIMARY KEY, 
    description TEXT NOT NULL 
  );""")

# figure out if this is really helpful for joins
#FOREIGN KEY (user_id) REFERENCES users (id)

#populate module and connector J# in table Sensors 
with open(ModuleIdHashpath, 'r') as f: 
   for ln in f:
      fd = ln.split(':')
      if (fd != [] ):        # should skip blank lines but not working
         if (fd[0] != '#'):  # skip lines starting with "#:" eg header line
            s = '("' + fd[0] + '", "' + fd[1].lstrip().rstrip()  + '")'
            q = 'INSERT INTO Modules (modID, description) VALUES ' + s 
            #print(q)
            z = con.execute(q) #z= mutes printing returned obj.


###################################################################
# drop the table if it exists, so it can be replaced
con.execute("DROP TABLE IF EXISTS Sensors")

#create and populate Sensors  table
con.execute("""
  CREATE TABLE IF NOT EXISTS Sensors (
     id TEXT PRIMARY KEY, 
     x   FLOAT,
     y   FLOAT,
     z   FLOAT, 
     modID  TEXT, 
     socket TEXT
  );""")

#populate sensor locations in table  Sensors
with open(locationPath, 'r') as f:
   for ln in f:
      fd = ln.replace(' ', '').split('{') #remove blanks, in case space was used as separater
      s = '("' + fd[0] + '", ' + fd[1].replace('}', '') + ' )' # rm '}' in fd[1]
      q = 'INSERT INTO Sensors (id, x, y, z) VALUES ' + s 
      zz = con.execute(q) #zz= mutes printing returned obj.


#for v in con.execute("PRAGMA table_info(Sensors)"): print(v)  #SHOW TABLE 
#con.execute("DROP TABLE Sensors")    #to start over


#populate module and connector in table Sensors 
with open(SensorIdHashpath, 'r') as f: 
   for ln in f:
      fd = ln.split()  #by white space
      if (fd != [] ):        # skip blank lines
         if (fd[0] != '#'):  # skip lines starting with "# " eg header line
            s = 'modID="' + fd[0] + '", socket="' + fd[1] + '"'
            q = 'UPDATE Sensors SET  ' + s + ' WHERE id="' + fd[2]  + '"'
            #print(q)
            z = con.execute(q) #z= mutes printing returned obj.


con.commit()
con.close()
