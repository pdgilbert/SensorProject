#!/usr/bin/env python3

"""
Make a new SQLite db with tables for sensor data and
insert  lines from data file generated by SensorDataReformat_v1.

This is only python with SQL. 
See extractSensorReadingsSliceSQLite.py for grasshopper python script to extract data.

Usage:
loadSensorReadingsSQLite --infile=InputFileName  --outdb=OutputDatabaseName 

Example:
loadSensorReadingsSQLite  --infile='short_test_output_v1.csv'  --outdb='SensorReadings.sqlite.db''
"""
import argparse
import os
import datetime
import sqlite3
#from sqlite3 import Error
#from sqlite3 import unixepoch

parser = argparse.ArgumentParser(description= 
           'Create and populate SQLite db.')

parser.add_argument('--infile', type=str, default='output_v1.csv',
                    help='input data file as produced by SensorDataReformat_v1. Default: output_v1.csv')

#parser.add_argument('--sensorIdHash', type=str, default='Garage/sensorIdHash.txt',
#                    help='input data file as produced bySensorDataReformat_v1. Default: Garage/sensorIdHash.txt')

parser.add_argument('--outdb', type=str, default='SenorReadings.sqlite.db',
                    help='input data file as produced bySensorDataReformat_v1. Default: SenorReadings.sqlite.db')

args = parser.parse_args()

inpath=args.infile
if not os.path.isfile(inpath): 
   print('file   '  + inpath +' does not exist.')
   exit()

#IdHashpath = args.sensorIdHash
#if not os.path.isfile(IdHashpath): 
#   print('file   '  + IdHashpath +' does not exist.')
#   exit()

dbpath = args.outdb
if os.path.isfile(dbpath): 
   print('file   ' + args.outdb +' exists. Delete it first.')
   print('Error exit.')
   exit()

###################################################################
con = sqlite3.connect(dbpath)


#create and populate ModuleId  table
con.execute("""
  CREATE TABLE IF NOT EXISTS ModuleId (
    modID TEXT PRIMARY KEY, 
    description TEXT NOT NULL 
  );""")

# figure out if this is really needed for joins
#FOREIGN KEY (user_id) REFERENCES users (id)

con.execute("""
  INSERT INTO
    ModuleId (modID, description)
  VALUES
    ('A', 'Floor profile from NE wall.'),
    ('B', 'Floor around person door. (2 extra unused sensors AW & AS)'),
    ('C', 'Floor around garage door.'),
    ('D', 'Floor profile from E corner.'),
    ('E', 'Floor profile from W corner.'),
    ('F', 'Floor profile from S corner'),
    ('K', 'Wall profile around window on NE wall.'),
    ('L', 'Roof profile up middle of SW roof.')
  """)

#create sensorData  table
con.execute("""
  CREATE TABLE IF NOT EXISTS SensorData (
    ref INTEGER PRIMARY KEY AUTOINCREMENT,
    id TEXT NOT NULL,
    temperature REAL,
    timeStamp TIMESTAMP
  );""" )

i=0
e=0
#populate sensorData  table
with open(inpath, 'r') as f:
   for ln in f:
      i += 1
      fd = ln.split(',')  
      s = '("' + fd[0] + '", ' + fd[1] + ', "' + fd[2].lstrip() + '" )' # rm leading blank fd[2]
      q = 'INSERT INTO SensorData (id, temperature, timeStamp) VALUES ' + s 
      try:
         z = con.execute(q) #z= mutes printing of returned obj
      except:
         e += 1
         #print("query '" + q + "' failed!")
         #print("ln    '" + ln + "'")

print(inpath + " lines " + str(i))
print("error lines " + str(e))

# This is not used when the module&socket is replaced by the sensorId in SensorDataReformat
##create SensorId  table
#con.execute("""
#  CREATE TABLE IF NOT EXISTS SensorId (
#    id TEXT PRIMARY KEY, 
#    modID  TEXT NOT NULL, 
#    socket TEXT NOT NULL
#  );""")
##
##populate SensorId  table
#with open(IdHashpath, 'r') as f: 
#   for ln in f:
#      fd = ln.split()  #by white space
#      if (fd != [] ):        # skip blank lines
#         if (fd[0] != '#'):  # skip lines starting with "# " eg header line
#            s = '("' + fd[2] + '", "' + fd[0] + '", "' + fd[1] + '" )' # leading blank fd[2]
#            q = 'INSERT INTO SensorId (id, modID, socket) VALUES ' + s 
#            #print(q)
#            z = con.execute(q) #z= mutes printing returned obj.

con.commit()
con.close()
